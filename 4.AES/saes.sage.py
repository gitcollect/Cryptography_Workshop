# -*- coding: utf-8 -*-
# This file was *autogenerated* from the file saes.sage
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_0x80 = Integer(0x80); _sage_const_8 = Integer(8); _sage_const_0x30 = Integer(0x30); _sage_const_12 = Integer(12); _sage_const_16 = Integer(16)#!/usr/bin/env sage

# Implemented the Simplified AES algorithm as described in
# Stalling's book and the following paper:
# <https://stud.fh-wedel.de/handout/Beuster/ss2015/crypto/s-aes-spec.pdf>
#
# Hint: A detailed walk-through of an encryption and a decryption
# operation is given in the following paper:
# <https://stud.fh-wedel.de/handout/Beuster/ss2015/crypto/CSS322Y12S2H02-Simplified-AES-Example.pdf>

def xor(a, b):
    def h(x,y):
        if(x==y):
            return(_sage_const_0 )
        else:
            return(_sage_const_1 )
    return(map(lambda (x, y): h(x,y), zip(a,b)))


def int2blist(n, length):
    b = bin(n)
    l = string2blist(b[_sage_const_2 :])
    return([_sage_const_0 ]*(length-len(l)) + l)
    
def string2blist(s):
    return(map(int, list(s)))

# Sonst stehen hier nach der S-Box: 
# 'sage.rings.finite_rings.element_givaro.FiniteField_givaroElement'
# drin. Dann schlagen sp√§ter Operationen fehl...
def convertToIntList(data):
	res = []
	for i in range(_sage_const_4 ):
		res.append(int(data[i]))
	return res

def sbox(nib):
	b0 = nib[_sage_const_0 ]
	b1 = nib[_sage_const_1 ]
	b2 = nib[_sage_const_2 ]
	b3 = nib[_sage_const_3 ]
	
	L = GF(_sage_const_2 **_sage_const_4 , names=('a',)); (a,) = L._first_ngens(1)
	V = VectorSpace(GF(_sage_const_2 ),_sage_const_4 )
	m = Matrix(L,
			   [ [_sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_1 ]
			   , [_sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_1 ]
			   , [_sage_const_1 , _sage_const_1 , _sage_const_1 , _sage_const_0 ]
			   , [_sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_1 ]
			   ])
	a = V([_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 ])

	sbox_in = [b0,b1,b2,b3]
	
	# [0,0,0,0] is a special case.
	if sbox_in == [_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ]:
		sbox_out = [_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]
	else:
		b = V(int2blist((~L([b3,b2,b1,b0])).integer_representation(),
					  _sage_const_4 ))
		sbox_out = convertToIntList(list(m*b+a))
	return sbox_out
	
def bigSBox(data):
	return sbox(data[:_sage_const_4 ]) + sbox(data[_sage_const_4 :_sage_const_8 ]) + sbox(data[_sage_const_8 :_sage_const_12 ]) + sbox(data[_sage_const_12 :])
		
def inv_sbox(nub):
	L = GF(_sage_const_2 **_sage_const_4 , names=('a',)); (a,) = L._first_ngens(1)
	V = VectorSpace(GF(_sage_const_2 ),_sage_const_4 )
	m = Matrix(L,
			   [ [_sage_const_1 , _sage_const_0 , _sage_const_1 , _sage_const_1 ]
			   , [_sage_const_1 , _sage_const_1 , _sage_const_0 , _sage_const_1 ]
			   , [_sage_const_1 , _sage_const_1 , _sage_const_1 , _sage_const_0 ]
			   , [_sage_const_0 , _sage_const_1 , _sage_const_1 , _sage_const_1 ]
			   ])
	a = V([_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_1 ])
	for b0 in xrange(_sage_const_0 ,_sage_const_2 ):
		for b1 in xrange(_sage_const_0 ,_sage_const_2 ):
			for b2 in xrange(_sage_const_0 ,_sage_const_2 ):
				for b3 in xrange(_sage_const_0 ,_sage_const_2 ):
					sbox_in = [b0,b1,b2,b3]
					# [0,0,0,0] is a special case.
					if sbox_in == [_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ]:
						sbox_out = [_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]
					else:
						b = V(int2blist((~L([b3,b2,b1,b0])).integer_representation(),
									  _sage_const_4 ))
						sbox_out = list(m*b+a)
						
					if sbox_out == nub:
						return sbox_in
	
def inv_bigSBox(data):
	return inv_sbox(data[:_sage_const_4 ]) + inv_sbox(data[_sage_const_4 :_sage_const_8 ]) + inv_sbox(data[_sage_const_8 :_sage_const_12 ]) + inv_sbox(data[_sage_const_12 :])

# 8 Bit Nibble. 
def rotNib(nib):
	return nib[_sage_const_4 :] + nib[:_sage_const_4 ]
	
# 8 Bit Nibble.
def subNib(nib):
	return sbox(nib[:_sage_const_4 ]) + sbox(nib[_sage_const_4 :])

def pp(b):
    """Pretty print bit lists"""
    t = "".join(map(str, b))
    r = ""
    for i in xrange(_sage_const_0 , len(t), _sage_const_4 ):
        r += t[i:i+_sage_const_4 ] + ' '
    return(r)

# Since the mix column operations are tricky, the following
# implementations are provided for your convenience.
def mix_col(d, inv=False):
    L = GF(_sage_const_2 **_sage_const_4 , names=('a',)); (a,) = L._first_ngens(1);
    V = VectorSpace(GF(_sage_const_2 ),_sage_const_8 )
    if inv:
        MixColumns_matrix = Matrix(L, [[a**_sage_const_3 +_sage_const_1 ,a],[a,a**_sage_const_3 +_sage_const_1 ]])
    else:
        MixColumns_matrix = Matrix(L, [[_sage_const_1 ,a**_sage_const_2 ],[a**_sage_const_2 ,_sage_const_1 ]])
    d0 = d[_sage_const_0 :_sage_const_4 ]
    d0.reverse()
    d1 = d[_sage_const_4 :_sage_const_8 ]
    d1.reverse()
    d2 = d[_sage_const_8 :_sage_const_12 ]
    d2.reverse()
    d3 = d[_sage_const_12 :_sage_const_16 ]
    d3.reverse()
    
    dMatrix = Matrix(L, [[d0, d2], [d1, d3]])
    
    matrixProduct = MixColumns_matrix*dMatrix
    r = []
    for j in xrange(_sage_const_2 ):
        for i in xrange(_sage_const_2 ):
            r += int2blist(int(matrixProduct[i][j]._int_repr()), _sage_const_4 )
    return(r)

def inv_mix_col(d):
    return(mix_col(d=d, inv=True))

def generateKeys(key):
	keys = []
	
	w0 = key[:_sage_const_8 ]
	w1 = key[_sage_const_8 :]
	w2 = xor(w0, xor(int2blist(_sage_const_0x80 , _sage_const_8 ), subNib(rotNib(w1))))
	w3 = xor(w2, w1)
	w4 = xor(w2, xor(int2blist(_sage_const_0x30 , _sage_const_8 ), subNib(rotNib(w3))))
	w5 = xor(w4, w3)
	keys.append(w0+w1)
	keys.append(w2+w3)
	keys.append(w4+w5)
	
	return keys
	
def shiftRow(data):
	return data[:_sage_const_4 ] + data[_sage_const_12 :] + data[_sage_const_8 :_sage_const_12 ] + data[_sage_const_4 :_sage_const_8 ]

def addRoundKey(data, key):
	return xor(data, key)

def saes_encrypt(plaintext, key):
    
    ciphertext = plaintext
    keys = generateKeys(key)    
    ciphertext = addRoundKey(ciphertext, keys[_sage_const_0 ])
    
    ####### Round 1:
    ciphertext = bigSBox(ciphertext)
    ciphertext = shiftRow(ciphertext)  
    ciphertext = mix_col(ciphertext)    
    ciphertext = addRoundKey(ciphertext, keys[_sage_const_1 ])
    
    ###### Round 2:    
    ciphertext = bigSBox(ciphertext)
    ciphertext = shiftRow(ciphertext)
    ciphertext = addRoundKey(ciphertext, keys[_sage_const_2 ])    
    
    return ciphertext
    
def saes_decrypt(ciphertext, key):
    
    plaintext = ciphertext
    keys = generateKeys(key)
    plaintext = addRoundKey(plaintext, keys[_sage_const_2 ])
    plaintext = shiftRow(plaintext)
    
    plaintext = inv_bigSBox(plaintext)
    plaintext = addRoundKey(plaintext, keys[_sage_const_1 ])
    plaintext = inv_mix_col(plaintext)
    
    plaintext = shiftRow(plaintext)
    plaintext = inv_bigSBox(plaintext)
    plaintext = addRoundKey(plaintext, keys[_sage_const_0 ])
    
    return plaintext

def test():
    for (plaintext, key, ciphertext) in [
         (# Stallings, Exercise 5.10 / 5.12 / 5.14
          '0110111101101011',
          '1010011100111011',
          '0000011100111000')
        ,(# Gordon
          '1101011100101000',
          '0100101011110101',
          '0010010011101100')
        ,(# Holden
          '0110111101101011',
          '1010011100111011',
          '0000011100111000')
        ]:
        plaintext = string2blist(plaintext)
        ciphertext = string2blist(ciphertext)
        key = string2blist(key)
        assert(saes_encrypt(plaintext=plaintext, key=key)
               == ciphertext)
        assert(saes_decrypt(ciphertext=ciphertext, key=key)
               == plaintext)
test()
