# This file was *autogenerated* from the file chinese_remainder.sage
from sage.all_cmdline import *   # import sage library
_sage_const_3 = Integer(3); _sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_4 = Integer(4); _sage_const_1813 = Integer(1813); _sage_const_9 = Integer(9); _sage_const_8 = Integer(8); _sage_const_39 = Integer(39); _sage_const_23 = Integer(23); _sage_const_973 = Integer(973); _sage_const_678 = Integer(678)#!/usr/bin/env sage
"""Calculating with Chinese Remainder Theorem"""

# In this assignment, you will use the Chinese Remainder Theorem to do
# some calculations. First, you will have to write a function that
# converts a given integer i in Z_M to a tuple of remainders and back.
#
# In this assignment, we use the following data structure to represent
# the residuals:
#
# [(r_1, m_1), (r_2, m_2), ..., (r_3, m_3)]
#
# For example, Sun Zi's problem is represented as
#
# [(2,3), (3,5), (2,7)]
#
# Hint: sage function factor() factorizes a number into its prime
# factors.

#
# Statt i mod M zu berechnen (was bei grossen Zahlen sehr aufwaendig ist),
# berechnen wir die Primfaktoren von M und rechnen:
# [(i mod M_0, M_0), (i mod M_1, M_1)]
#
def int2remainder(i, M): # i == 23
	"""Convert an integer number to a list of pairs (residual, modulus).

	M shall be the product of the moduli, i.e. M=m_1;\ldots;m_n."""
	res = []
	
	for prime in list(factor(M)):
		res.append(tuple([i % prime[_sage_const_0 ]**prime[_sage_const_1 ], prime[_sage_const_0 ]**prime[_sage_const_1 ]]))
		
	return res

def extractProductExceptAtN(chineseRemainder, n):
	res = _sage_const_1 
	for i in range(len(chineseRemainder)):
		if i != n:
			res *= chineseRemainder[i][_sage_const_1 ]
	return res
	
def extractModulusNumber(chineseRemainder):
	return chineseRemainder[_sage_const_0 ][_sage_const_1 ] * extractProductExceptAtN(chineseRemainder, _sage_const_0 )

def findNumberModZeroExceptForI(chineseRemainder, product, at):
	factor = _sage_const_1 
	while True:
		found = True
		for i in range(len(chineseRemainder)):
			if i == at:
				# muss != 0 sein!
				if (factor*product) % chineseRemainder[i][_sage_const_1 ] != chineseRemainder[i][_sage_const_0 ]:
					found = False
					break
			else:
				# muss == 0 sein!
				if (factor*product) % chineseRemainder[i][_sage_const_1 ] != _sage_const_0 :
					found == False
					break
		if found:
			return factor*product
		factor += _sage_const_1 


def remainder2int(chineseRemainder):
	"""Convert a list of pairs (residual, modulus) to an integer."""

	bigNumber = _sage_const_0 
	
	for i in range(len(chineseRemainder)):
		product = extractProductExceptAtN(chineseRemainder, i)
		bigNumber += findNumberModZeroExceptForI(chineseRemainder, product, i)
	
	return bigNumber % extractModulusNumber(chineseRemainder)	

def remainderAdd(a, b, M):
	"""Calculate (a+b) % M using the Chinese Remainder Theorem."""
	
	lista = int2remainder(a, M)
	listb = int2remainder(b, M)
	listc = []
	
	print lista
	print listb
	
	for i in range(min(len(lista), len(listb))):
		listc.append( tuple([(lista[i][_sage_const_0 ] + listb[i][_sage_const_0 ]) % lista[i][_sage_const_1 ], lista[i][_sage_const_1 ]]))
		
	print listc
	
	print remainder2int(listc)
	
	return remainder2int(int2remainder(a+b, M))

def testRepresentation():
	# Lady
	x=[(_sage_const_4 ,_sage_const_5 ), (_sage_const_7 ,_sage_const_8 ), (_sage_const_3 ,_sage_const_9 )]
	assert(remainder2int(x) == _sage_const_39 )
	# Stallings, p. 280
	x=int2remainder(_sage_const_973 ,_sage_const_1813 )
	assert((remainder2int(x))== _sage_const_973 )
	# Sun Zi
	x=[(_sage_const_2 ,_sage_const_3 ), (_sage_const_3 ,_sage_const_5 ), (_sage_const_2 ,_sage_const_7 )]
	assert(remainder2int(x) == _sage_const_23 )
	
def testAdd():
	# Stallings, p. 264
	assert(remainderAdd(_sage_const_678 , _sage_const_973 , _sage_const_1813 ) == (_sage_const_678 +_sage_const_973 ))

if __name__ == "__main__":
	testRepresentation()
	testAdd()
